[{"uri":"https://noissefnoc.github.io/","title":"","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/categories/","title":"Categories","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/posts/","title":"Posts","tags":["index"],"categories":[],"series":[],"description":"Post page","content":""},{"uri":"https://noissefnoc.github.io/tags/","title":"Tags","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/tags/terraform/","title":"terraform","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/posts/terraform-console/","title":"terraform の Syntax と挙動を確認するのに terraform console を使う","tags":["terraform"],"categories":[],"series":[],"description":"","content":"久々に terraform を使うことになって大分 Syntax が変わっていたので、いくつか試してみたかったので、シンタックスチェックと REPL について調べた。\nSyntax 確認 Command: validate - terraform を使う。 terraform plan でもチェックが走るが、こちらだとリモートのリソースにアクセスしに行くのでファイルのみでのオフラインチェックができない。\nまた、 terraform validate を実行するためには terraform init を実行しておかなければならないのだが、 backend がリモートの場合 terraform init 実行時にリモートアクセスが走るので\n$ terraform init -backend=false を一度実行しておく。\n挙動確認 Command: console - terraform を使う。\n現在のディレクトリの state を使いたければ\n$ terraform console で REPL モードに入る。他の state を使いたければ -state=path で指定。\nREPL は exit ないしは C-C or C-D で終了。\nまた、以下のようにパイプで標準入力に HCL を渡せば\n$ echo \u0026quot;1 + 1\u0026quot; | terraform console 2 評価結果が返ってくる。\n"},{"uri":"https://noissefnoc.github.io/categories/tips/","title":"tips","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/tags/aws/","title":"aws","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/posts/check-aws-account-id-and-user-by-cli/","title":"AWS CLI で現在の認証情報のアカウント ID とユーザを確認する","tags":["aws"],"categories":[],"series":[],"description":"","content":"諸事情で AWS 認証情報ファイル ~/.aws/credentials にプロファイルを書き込まずに環境変数だけで作業をしているときに、現在のアカウントを確認したくなる時があるので調べてみました。\nget-caller-identity - AWS CLI Command Reference\n$ aws sts get-caller-identity で、以下スキーマの JSON が返ってくる。\n1 2 3 4 5  { \u0026#34;Account\u0026#34;: \u0026#34;AWS_ACCOUNT_TWELVE_DIGIT\u0026#34;, \u0026#34;UserId\u0026#34;: \u0026#34;AWS_USER_ID\u0026#34;, \u0026#34;Arn\u0026#34;: \u0026#34;arn:aws:iam::AWS_ACCOUNT_TWELVE_DIGIT:user/USER\u0026#34; }   毎回実行するのもアレなので、本当は認証情報を環境変数に書き出すさいにユーザ定義環境変数にして書き出した方がいいのかもしれません。\n"},{"uri":"https://noissefnoc.github.io/categories/blog/","title":"blog","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/tags/github/","title":"github","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/posts/github-organization-search-tips/","title":"GtiHub の Organization 内だけに検索対象を絞る方法","tags":["github"],"categories":[],"series":[],"description":"","content":"そのままズバリ org:ORGNAME でできる。\nユーザまたは Organization のリポジトリ内の検索\nユーザの場合は同様に user:USERNAME になる。\n"},{"uri":"https://noissefnoc.github.io/tags/python/","title":"python","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/posts/python-cli-behavior-under-venv/","title":"Python の venv でインストールした CLI の挙動","tags":["python"],"categories":[],"series":[],"description":"","content":"Python の venv を使って仮想環境を作って pip install していくと venv/bin や venv/lib 以下にファイルがインストールされるまでは知っていたが、 source venv/bin/activate せずに venv/bin/some-cli したときの Python の環境はどれを使っているんだろうかと疑問になったので調べてみた。\n公式ドキュメントの venv \u0026ndash; 仮想環境の作成 にずばり答えが書いてあって\n 仮想環境にインストールされたスクリプトには、仮想環境の Python インタプリタを指す \u0026ldquo;shebang\u0026rdquo; 行があります。 これはつまり、スクリプトは PATH の値に関係無く、仮想環境のインタプリタで実行されるということです。\n ということで venv/bin/some-cli の shebang を見ると\n1  #! /path/to/project_root/venv/bin/python   となっており、該当 venv の Python が呼ばれるように指定されていた。\nそういう仕組みなのかと感心しました。\n"},{"uri":"https://noissefnoc.github.io/categories/reference/","title":"reference","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/posts/python-mutiplatform-userdir/","title":"Python でマルチプラットフォームのファイルパスを扱う","tags":["python"],"categories":[],"series":[],"description":"","content":"AWS のクレデンシャルファイルのパスが Widnows と　POSIX 互換システムで以下のように違う。\n Windows: %USERPROFILE%\\.aws\\credentials その他： $HOME/.aws/credentials  これをプラットフォームの分岐なしで記載したい。\n os.path.expanduser : マルチプラットフォームでユーザのホームディレクトリを取得 os.path.join : マルチプラットフォームのパスの結合 (セパレータを加味)  を使って以下のように記載する。\n1 2 3 4 5  from os.path import expanduser, join if __name__ == \u0026#39;__main__\u0026#39;: user_home_path = expanduser(\u0026#39;~\u0026#39;) aws_credential_file_path = join(user_home_path, \u0026#39;.aws\u0026#39;, \u0026#39;credentials\u0026#39;)   以上。\n"},{"uri":"https://noissefnoc.github.io/tags/zsh/","title":"zsh","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/posts/zsh-plugin-management-by-zplugin/","title":"zsh のプラグインマネージャーに zplugin を使うことにした","tags":["zsh"],"categories":[],"series":[],"description":"","content":"tl;dr macOS のバージョンアップに伴って zsh を使い始めたので、プラグインマネージャを検討した結果 zplugin を使うことにした。\n経緯 bash のときはプラグインマネージャーを使っていなかったけれど、 zsh 使っている人から Oh my zsh のような存在は聞かされていたので、プラグインあるだろうと思ってプラグインマネージャーを調べたところ\n vim で使っていた(多分 neobundle + vim-plug) プラグインマネージャと似たような設定方法 同じ設定方式の中では動作が速い  という理由で zplugin を選びました。\n設定 まだよく分かっていないのですが、コマンドタイプしていくとサジェストが出るプラグインと、ターミナル上でシンタックスハイライトが付くプラグインを入れてみました。\n~/.zshrc に以下を追加しておいて\n1 2  zplugin light zsh-users/zsh-autosuggestions zplugin light zdharma/fast-syntax-highlighting   再読み込みされたタイミングでインストールされていなければインストールされる仕組みになっています。\nこの後のTODO ちゃんと使いそうなプラグインと、起動時に読み込まなくてもいいプラグインなど、導入と精査を進めていきたいと思います。\n"},{"uri":"https://noissefnoc.github.io/posts/zsh-env-path-settings/","title":"zsh で環境変数 PATH 周りの設定","tags":["zsh"],"categories":[],"series":[],"description":"","content":"tl;dr macOS Catalina からユーザのログインシェルが zsh に変わり、 bash を使っていると「zsh を使え」と警告文が出るので、ボチボチ移行しています。\n今回は環境変数 PATH の設定の話についてのメモ。\n 環境変数の記述ファイル zsh で使える配列変数 path パスが存在するときだけ PATH に追加 PATH 中の重複パス削除  環境変数の記述ファイル 環境変数は ~/.zshenv に書くのが正しいらしいので、そちら側に移動。\nzsh で使える配列変数 path 環境変数 PATH と同期している配列変数 path が使える。\n1  export PATH=\u0026#34;/usr/local/bin:$PATH\u0026#34;   は\n1 2 3 4  path=( /usr/local/bin $path )   と同義。path の方が追加/削除が簡単なのと、次に書くパスが存在する時だけ追加するオプションが利用できるのでこっちを使う。\nパスが存在する時だけ PATH に追加 配列変数 path だと、追加パスの末尾に (N-/) をつけることでパスが存在する場合だけ追加することができる。\n1 2 3 4 5  path=( $HOME/bin(N-/) /usr/local/bin $path )   のような形。 .*env 系など、ユーザが自分で作成しないとないパスを PATH に追加するときに便利。\nPATH の中の重複パス削除 諸々あって、 PATH の追加が何回も呼ばれてしまって、重複したパスが追加されたりするケースで、 bash だと少しサイクが必要だったが、zsh だと\n1  typeset -U path   を使えば良い。これを ~/.zshrc の最後に書いてる。\n"},{"uri":"https://noissefnoc.github.io/posts/python3-type-hinting-mypy-summary/","title":"Python3 の Type Hinting の早見表","tags":["python"],"categories":[],"series":[],"description":"","content":"Python 3.5+ から PEP484 にある型ヒントで「この場合どう書いたらいいんだっけ」というのが分からなかったので調べてみた。\nすると Mypy のサイトに以下のようなページがありました。\nType hints cheat sheet (Python 3)\n関数のディフォルト値 例えば関数のディフォルト値なら\n1 2  def inc(d: int = 1): return d + 1   のように変数ではなく、型の方にディフォルト値を書く。\nクラス 独自クラスに関してはそのままが型になる\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  from typing import List class Hoge: # これはコンストラクタが返ってきてる気がするけど None らしい def __init__(self) -\u0026gt; None: self.foo: List[str] = [] # インスタンスメソッドの self の方は省略する def i_method(self, i: int) -\u0026gt; int; return i + 1 if __name__ == \u0026#39;__main__\u0026#39;: # ユーザ定義のクラスの型はそのままクラス名 x: Hoge = Hoge()   その他 自分で書いた範囲に関してはこのページの内容で問題なさそうですが\n 外部のライブラリを使ったときはどうなるのか 有名なライブラリには型ファイルが用意されているものか  あたりはまた別途調べてみようと思います。\n"},{"uri":"https://noissefnoc.github.io/posts/python-input-func-to-stderr/","title":"Python の input 関数の出力を標準エラー出力に向ける","tags":["python"],"categories":[],"series":[],"description":"","content":"もう少しマシな方法があるかもしれないけれど、一旦できたので記録。\nPython で CLI を作っていて、Username/Password を対話的に入力して環境変数を export する構文を出力したいという要件があった。\n例示すると以下\n# そのまま実行すると以下 $ python cli.py Username: # ユーザ名を対話的に入力 Password: # パスワードを対話的に入力 export X_TOKEN=yyyyy # こうやると環境変数に定義されて欲しい $ $(python cli.py) $ echo ${X_TOKEN} yyyyy 上記のようにするためにはUsernameとPasswordのプロンプト両方が標準出力ではなく、標準エラー出力に出力して、環境変数の箇所だけを標準出力に出力する必要がある。\nPassowrd のように echo back させない対話入力は getpass モジュールの getpass 関数を使う\ngetpass \u0026mdash; 可搬性のあるパスワード入力機構\ngetpass 関数には stream 引数にプロンプトの出力先を変更できる。\n1 2 3 4 5 6  from getpass import getpass import sys if __name__ == \u0026#39;__main__\u0026#39;: password = getpass(\u0026#39;Password: \u0026#39;, stream=sys.stderr)   問題は echo back する方で、標準の input 関数を使うのだけど、これには出力先を選択するオプションがない。\n組み込み関数 \u0026mdash; input()\n調べてみると10年以上前から issue には上がっていた\nChange input() to always prompt to stderr\nここに上がっているパッチだと単純に stdout を stderr に差し替えられていたが、マージされる様子はなさそうだった。\nPython のレイヤーで言うと getpass.getpass と同じようにオプション引数を追加すればいいような話ではあるが、実態の PyOS_Readline あたりの諸々に影響がある？\n暫定的な対応をすると getpass 関数と合わせて以下のような処理を書いた。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  import sys from typing import IO def getusername(prompt: str, stream: IO[str] = sys.stderr) -\u0026gt; str: # 標準出力を指定した先に変更 sys.stdout = stream # 対話的に入力を取得 username = input(prompt) # 標準出力を処理起動時の標準出力に戻す sys.stdout = sys.__stdout__ return username if __name__ == \u0026#39;__main__\u0026#39;: try: username = getusername(\u0026#39;Username: \u0026#39;) except KeyboardInterrupt: # input 関数実行時に Ctrl-C などで止められたときに標準出力を元に戻しておく # ここやる必要ないかも sys.stdout = sys.__stdout__   他にいい方法があるかもしれないが、一旦はこんなもので\n"},{"uri":"https://noissefnoc.github.io/tags/github-actions/","title":"github-actions","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/tags/golang/","title":"golang","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/posts/hugo-blog-open/","title":"Hugo + GitHub Pages + GitHub Actions で技術メモを開始した","tags":["golang","github-actions"],"categories":[],"series":[],"description":"","content":"GitHub の草を生やすのにできればコードを書き続けたいのですが、昨年トライしてみたところそうもいかないことがありました。\n過分余暇時間で Blog を書いたりスニペットを書いたりもするのですが、両方とも GitHub の Contributions に反映されないので、反映できるようにまずは　Blog を GitHub Pages にしてみました。\nスタックは\n Visual Code Studio: エディタ Hugo: 静的ファイルネジェレータ Hugo テーマ: Zzo ホスティング: GitHub Pages ジェネレート: GitHub Actions  で実施しています。\ngit push をトリガーにして GitHub Actions で master ブランチにジェネレートされた静的ファイルをコミットし、 GitHub Pages に反映するようにしています。\nReference  Hugo Hugo Theme Zzo GitHub Actions Hugo Setup GitHub Actions GitHub Pages  "},{"uri":"https://noissefnoc.github.io/posts/github-basic-auth-deprecation/","title":"GitHub の Basic Auth の Deprecation に伴って Homebrew を Personal Token で認証するように変更した","tags":["github","homebrew"],"categories":[],"series":[],"description":"","content":"GitHubから [GitHub] Deprecation Notice というタイトルで以下の内容のメールが来た\n You recently used a password to access an endpoint through the GitHub API using Homebrew/*************. We will deprecate basic authentication using password to this endpoint soon: ※ User Agentは一部マスク\nhomebrew コマンドで Basic Auth を使っていて Personal Access Token に対応してなかった様子。 man brew でそれらしいセクションを探すと\n HOMEBREW_GITHUB_API_TOKEN A personal access token for the GitHub API, used by Homebrew for features such as brew search. You can create one at https://github.com/settings/tokens. If set, GitHub will allow you a greater number of API requests. For more information, see: https://developer.github.com/v3/#rate-limiting Note: Homebrew doesn't require permissions for any of the scopes. とあったので Settings \u0026gt; Developer \u0026gt; Personal Access Token で homebrew 用の Token を作成して環境変数にセットした。\n"},{"uri":"https://noissefnoc.github.io/tags/homebrew/","title":"homebrew","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/categories/mainteinance/","title":"mainteinance","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/archive/","title":"Archive","tags":[],"categories":[],"series":[],"description":"Archive Page","content":"archive page\n"},{"uri":"https://noissefnoc.github.io/tags/bigquery/","title":"bigquery","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/posts/bigquery-gis-to-datastudio/","title":"Bigquery GIS のデータを Google DataStudio で使う方法","tags":["bigquery","datastudio","gis","sql"],"categories":[],"series":[],"description":"","content":"tl;dr Google BigQuery の GEOGRAPHY データ型はそのままでは Google DataStudio では使えないので(取り込み対象カラムとして表示されない)以下のように変換しておく必要がある。\n1 2 3 4  SELECT CONCAT(CAST(ST_Y(p) AS STRING), \u0026#34;,\u0026#34;, CAST(ST_X(p) AS STRING)) AS lat_lng FROM my_project.geo_table   このさい\n GEOGRAPHY データ型  (経度, 緯度) で保存されている (つまり ST_Y で緯度、 ST_X で経度が取れるということ)   DataStudio の緯度経度型  緯度,経度 のフォーマットを期待している    と、緯度経度の順番が逆になっていることに注意。\n本文 きっかけ Google BigQuery の地理情報をデータポータルで可視化する仕事があったが、データポータルの BigQuery テーブル指定だと GEOGRAPHY 型のカラムが出てこなかった。\n対応 データポータルで読み取れるのは緯度経度なので\n BigQuery であらかじめ変換したテーブルを用意しておく データポータルの BigQuery 取得でカスタムクエリを書く  の方法が考えられますが、今回は後者を選びました。\nカスタムクエリに以下のようなクエリをセットして\n1 2 3 4 5 6 7  -- カスタムクエリに記載するクエリ SELECT -- その他のカラム  CONCAT(CAST(ST_Y(p) AS STRING), \u0026#34;,\u0026#34;, CAST(ST_X(p) AS STRING)) AS lat_lng FROM my_project.geo_table -- その他絞り込み条件   データポータルのカラムの設定マッピングで「地理フィールド」\u0026gt;「緯度/経度」を選択して完了です。\nReference  BigQuery GIS の構文リファレンス - ST_X: SQL のサンプルの記載がある データポータルのヘルプ - 地図のリファレンス：「地理フィールド」の「緯度 / 経度」の箇所  "},{"uri":"https://noissefnoc.github.io/tags/datastudio/","title":"datastudio","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/tags/gis/","title":"gis","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/tags/sql/","title":"sql","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/series/","title":"Series","tags":[],"categories":[],"series":[],"description":"","content":""}]