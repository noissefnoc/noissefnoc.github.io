[{"uri":"https://noissefnoc.github.io/","title":"","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/categories/","title":"Categories","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/posts/introduction-of-gjson/","title":"GJSON を使ってみた","tags":["golang","library"],"categories":[],"series":[],"description":"","content":"Golang の あるライブラリにコントリビュートしようとしたときに、JSON のハンドリングを tidwall/gjson でやっていたので使い方のメモ。\nGJSON のコンセプトは README.md\nGJSON is a Go package that provides a fast and simple way to get values from a json document. It has features such as one line retrieval, dot notation paths, iteration, and parsing json lines. とあるように JSON から簡単に値を取得することを目的にしている。ので、APIとしても既存の JSON を修正したり、 JSON を新しく作成する機能はない。\n通常 Golang で JSON を扱うときは構造体を定義して json.Marshal ないしは json.Unmarshal して使うが、GJSON の場合は JSON 文字列に対して\n1  gjson.Get(jsonStr, \u0026#34;pathStr\u0026#34;)   の構文で構造体を介さずに値を処理できる。\nその分値の取得に対して DSL を提供しており、複雑な構造からも値を取得できるようになっている。\n GJSON Path Syntax  自分で JSON と Path Syntax を入力できる対話的な Playground が提供されているので、まずはそこで確認するのがいいかもしれません。\n GJSON Playground  サンプルだと\n1 2 3 4 5 6 7 8 9 10 11  { \u0026#34;name\u0026#34;: {\u0026#34;first\u0026#34;: \u0026#34;Tom\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Anderson\u0026#34;}, \u0026#34;age\u0026#34;:37, \u0026#34;children\u0026#34;: [\u0026#34;Sara\u0026#34;,\u0026#34;Alex\u0026#34;,\u0026#34;Jack\u0026#34;], \u0026#34;fav.movie\u0026#34;: \u0026#34;Deer Hunter\u0026#34;, \u0026#34;friends\u0026#34;: [ {\u0026#34;first\u0026#34;: \u0026#34;Dale\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Murphy\u0026#34;, \u0026#34;age\u0026#34;: 44, \u0026#34;nets\u0026#34;: [\u0026#34;ig\u0026#34;, \u0026#34;fb\u0026#34;, \u0026#34;tw\u0026#34;]}, {\u0026#34;first\u0026#34;: \u0026#34;Roger\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Craig\u0026#34;, \u0026#34;age\u0026#34;: 68, \u0026#34;nets\u0026#34;: [\u0026#34;fb\u0026#34;, \u0026#34;tw\u0026#34;]}, {\u0026#34;first\u0026#34;: \u0026#34;Jane\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Murphy\u0026#34;, \u0026#34;age\u0026#34;: 47, \u0026#34;nets\u0026#34;: [\u0026#34;ig\u0026#34;, \u0026#34;tw\u0026#34;]} ] }   にような JSON が使われていて、順に階層をたどるのは特に説明が要らないと思うので、配列要素の取得の Path について。\n上記例だと friends の配列要素へのアクセスがそれにあたる。\n// index access friends.0.nets \u0026gt;\u0026gt; [\u0026quot;ig\u0026quot;, \u0026quot;fb\u0026quot;, \u0026quot;tw\u0026quot;] // 各要素を全部取得。#単体だと配列の個数になる friends.#.nets \u0026gt;\u0026gt; [[\u0026quot;ig\u0026quot;, \u0026quot;fb\u0026quot;, \u0026quot;tw\u0026quot;], [\u0026quot;fb\u0026quot;, \u0026quot;tw\u0026quot;], [\u0026quot;ig\u0026quot;, \u0026quot;tw\u0026quot;]] // 他の要素でフィルタして該当要素だけを取得 // 一致だけでなく、大小関係やパターンマッチ他の下部要素での一致なども可能 friends.#(first==\u0026quot;Dale\u0026quot;).nets \u0026gt;\u0026gt; [\u0026quot;ig\u0026quot;, \u0026quot;fb\u0026quot;, \u0026quot;tw\u0026quot;] また、ネストした値を Golang 側で処理したい場合はも戻り値の result.Array() を range でループさせるか result.ForEach でイテレーターを回す。\n1 2 3 4 5  result := gjson.Get(json, \u0026#34;friends\u0026#34;) result.ForEach(func(key, value gjson.Result) bool { fmt.Println(value.String()) return true // 戻り値は次のイテレーションに進むかどうか })   ひとまずはこんなところか。\n"},{"uri":"https://noissefnoc.github.io/tags/golang/","title":"golang","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/categories/golang/","title":"golang","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/tags/library/","title":"library","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/categories/library/","title":"library","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/posts/","title":"Posts","tags":["index"],"categories":[],"series":[],"description":"Post page","content":""},{"uri":"https://noissefnoc.github.io/tags/","title":"Tags","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/posts/cannot-get-c-files-by-go-mod-vendor/","title":"Go 1.13 の go mod vendor で C/C++ 系のファイルがダウンロードされない問題とその対応","tags":["golang","c/c++"],"categories":[],"series":[],"description":"","content":"tl;dr Go 1.13 の go mod vendor の仕様として package でないサブディレクトリはコピーされない。ので、パッケージの提供元が non-package directory に C/C++ 系のファイルを配置してると取得できない。\nRuss Cox も golang/go の Issue のコメントでそう書いてるのでしゃーなし。\nエラーを見てそのディレクトリを削除して git clone するしかない。\nきっかけ あるパッケージを go mod vendor した後にビルドしようとして以下のエラーが起こった。\n# github.com/karalabe/hid vendor/github.com/karalabe/hid/hid_enabled.go:38:11: fatal error: 'hidapi/mac/hid.c' file not found #include \u0026quot;hidapi/mac/hid.c\u0026quot; ^~~~~~~~~~~~~~~~~~ 1 error generated. 該当のパッケージレポジトリは karalabe/hid で、レポジトリをみると\n hidpi/mac/hid.c  というCファイルがあるが、 vendor ディレクトリ側にはエラーメッセージどおり、そもそも hidpi ディレクトリごとない。\n調査 エラーメッセージで調べてみると Golang の公式レポジトリの以下の issue にたどり着いた。\n cmd/go: go mod -vendor prunes non-package directories #26366  で、 Russ Cox が「残念だけどそれが仕様(go mod では non-package のサブディレクトリは取ってこない)なので、必要なやつコピーしてくれ」と言って issue を close しているのでしゃーなし(結構 downvote もらってるけど)。\nとはいえ、無碍にしているわけではなくて、同 Issue で紹介された modvendor コマンドの Golang 本体へのポーティングを提案する Issue\n cmd/go: add modvendor sub-command #27618  では Russ Cox がこの Issue に Go1.14 と Backlog のマイルストーンを設定しているので、対応してくれないわけではなさそう。\nで、先日リリースがあった Go1.14\n Go 1.14 Release Notes  には、その記述がない気がするけど、Issue も Close されてないしまだ対応されていないということか。\n対応 仕方ないので vendor のディレクトリ配下の hid ディレクトリを削除して git clone した。\n仕様的には仕様を守って作っていない方が悪いのでしょうが、早いところ対応して欲しいですね。\n"},{"uri":"https://noissefnoc.github.io/tags/terraform/","title":"terraform","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/posts/terraform-list-to-string/","title":"terraform の list の JSON Array の文字列表現への変換","tags":["terraform"],"categories":[],"series":[],"description":"","content":"terraform v0.12.19 で確認。\nterraform で AWS IAM Policy Document を作成するさいにヒアドキュメントに JSON Array を埋め込みたいケースがあった。\nterraform 内部では list で処理をしたいのだが、組み込みの tostring 関数は tostring Function 通りで\n Only the primitive types (string, number, and bool) can be converted to string. All other values will produce an error.\n と、 list には対応していない。\nということで、文字列表現を自分で生成する必要がある。\njoin 関数で結合する。\n1  \u0026#34;[\\\u0026#34;${join(\u0026#34;\\\u0026#34;, \\\u0026#34;\u0026#34;, var.target_list)}\\\u0026#34;]\u0026#34;   var.list の中身が [\u0026quot;foo\u0026quot;, \u0026quot;bar\u0026quot;] だとすると\n\u0026quot;[\\\u0026quot;foo\\\u0026quot;,\\\u0026quot;bar\\\u0026quot;]\u0026quot; になる。これが変数として埋め込むと\n[\u0026quot;foo\u0026quot;,\u0026quot;bar\u0026quot;] になる。\nこのままだと var.list の中身が [] のときに\n[\u0026quot;\u0026quot;] になる。長さが0での条件分岐が必要だが、単純に式で書こうとするとうまくいかないので Directives を使う\n1  \u0026#34;%{ if length(var.list) \u0026gt; 0 }[\\\u0026#34;${join(\u0026#34;\\\u0026#34;,\\\u0026#34;\u0026#34;, var.list)}\\\u0026#34;]%{ else }[]%{ endif }\u0026#34;   これで var.list の中身が [] のときに文字列の評価結果が\n[] になる。\n文字列にするときに制御やループがネストする場合、Directives 使わずに一度変数定義していたけれど、これで対応可能。\n"},{"uri":"https://noissefnoc.github.io/categories/tips/","title":"tips","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/posts/google-sheets-escape-double-quote/","title":"Google Sheets の数式内でのダブルクオートのエスケープ","tags":["gsuite","google-sheets"],"categories":[],"series":[],"description":"","content":"Google Sheets の数式内で文字列を結合するさいに、ダブルクォートを使いたい。\nが、バックスラッシュエスケープがダメで、色々調べてみたところ、Google Sheets はダブルクオートをダブルクォートでエスケープする派閥だった。\nつまり\n=CONCATENATE(\u0026quot;\u0026quot;\u0026quot;\u0026quot;, B1, \u0026quot;\u0026quot;\u0026quot;\u0026quot;) でいける。\nGoogle で検索するとダブルクォートの ASCII コード (34)を指定した\n=CONCATENATE(CHAR(34), B1, CHAR(34)) の用例が結構あったけれど、これだと一般の人には可読性低いのでエスケープ使った方がいいのではと思ってメモした。\n"},{"uri":"https://noissefnoc.github.io/tags/google-sheets/","title":"google-sheets","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/tags/gsuite/","title":"gsuite","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/posts/terrafrom-linter-tflint/","title":"tflint のインストールと設定","tags":["terraform"],"categories":[],"series":[],"description":"","content":"インストール macOS なので homebrew を使う。\n$ brew install tflint ルール設定 標準だと .tflint.hcl を読むので、そこに対象のルールを設定する。パスは --config オプションで変更可能。\ntflint/config.md\nに設定例がある。\n"},{"uri":"https://noissefnoc.github.io/posts/terraform-map-substraction/","title":"terraform で対象の key を 除いた Map を取得する","tags":["terraform"],"categories":[],"series":[],"description":"","content":"tl;dr terraform で対象の key を除いた Map を取得するには for で対応する。\n1  {for k, v in {a: 1, b: 2}: k =\u0026gt; v if !contains([\u0026#34;a\u0026#34;], k) }   確認した terraform のバージョンは v0.12.19 。\nやりたいこと terraform で AWS Config 対象のマネージドルールを指定するときに\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  locals { target_identifiers = { s3-bucket-public-read-prohibited = \u0026#34;S3_BUCKET_PUBLIC_READ_PROHIBITED\u0026#34; // 以下略 } } resource \u0026#34;aws_config_rule\u0026#34; \u0026#34;rule\u0026#34; { for_each = local.target_identifiers name = each.key // 中略 source = { owner = \u0026#34;AWS\u0026#34; source_identifier = each.value } }   と for_each を使いながら例示では直接内容を記載しているが target_identifiers のところに AWS Config のマネージドルールを記載していくことになる。\n上記のコードはモジュール側に配置されていて、基本的に対象とするリソースは設定しておきたいのだけど、アカウントによって個別の足し引きをしたいケースがあり、それに対応したい。\n足すのは\n1  merge(base_map, additional_map)   でよいのだが、引く方は list のときと同じく自前で対応する必要があることが分かった。\n※ base_map と additional_map に同じキーがあった場合は第二引数の additional_map の設定で上書きされる。\n対応 結論書くと\n1  {for k, v in {a: 1, b: 2}: k =\u0026gt; v if !contains([\u0026#34;a\u0026#34;], k) }   でよい。\n今回の対象の Map の要素は最大でも100ちょっとだし、個別に除外するものも数個なので大雑把でいいだろうという判断。\n総合すると以下のようなイメージか\n1 2 3  locals { target_map ={ for k, v in merge(module.aws_config.base_map, var.additional_map): k =\u0026gt; v if !contains(var.substraction_key_list, k) } }   で、 target_map を for_each に渡す。\n"},{"uri":"https://noissefnoc.github.io/posts/terraform-list-substraction/","title":"terraform の list 同士の差分 list を取得する","tags":["terraform"],"categories":[],"series":[],"description":"","content":"tl;dr terraform の list 同士の差分 list を取得したい場合、2020/02/03 時点では Builtin Functions に関数がないので、for で対応する。\n1  [for v in [1,2,3,4]: v if !contains([2, 4], v)]   確認した terraform のバージョンは v0.12.19 。\nやりたいこと terraform で AWS Config の対象リソースを個別に指定する場合に\n1 2 3 4 5 6 7 8 9 10 11 12  resource \u0026#34;aws_config_configuration_recorder\u0026#34; \u0026#34;config_recoder\u0026#34; { name = \u0026#34;default\u0026#34; role_arn = \u0026#34;${aws_iam_role.r.arn}\u0026#34; recording_group = { all_supported = false include_global_resource_types = false resource_types = [ // resourcelist here ] } }   と resource_types のところに AWS のリソースを list で列記していくことになる。\n上記のコードはモジュール側に配置されていて、基本的に対象とするリソースは設定しておきたいのだけど、アカウントによって個別の足し引きをしたいケースがあり、それに対応したい。\n足すのは\n1  distinct(concat(base_list, additional_list))   でよいのだが、引く方は調べてみたものの 標準の関数群 には該当のものがなかった。\nadd setsubtract function and docs #23424 でPRは出ているものの、まだマージされていない様子。\n対応 結論書くと\n1  [for v in base_list: v if !contains(substraction_list, v)]   でよい。\nbase_list の要素は最大でも100以下だし、個別に除外するものも数個なので大雑把でいいだろうという判断。\n総合すると以下のようなイメージか\n1 2 3 4  locals { add_list = distinct(concat(module.aws_config.base_list,var.additional_list)) target_list = [for r in add_list: r if !contains(var.substraction_list, r)] }   で、 target_list を resource_types に渡す。\n"},{"uri":"https://noissefnoc.github.io/tags/google-apps-script/","title":"google-apps-script","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/posts/create-jsonl-from-sheets-by-lodash/","title":"lodash.js を使って Google Sheets の入力値から JSONLを作成する","tags":["google-apps-script"],"categories":[],"series":[],"description":"","content":"tl;dr lodash.js の lodash.set を使ってヘッダに JavaScript Object の Path をヘッダにした Google Sheets の入力値から JSONL を生成する Google Apps Script を作成した。\nやりたいこと BigQuery のデータ加工処理のテストのためにテストデータが必要になった。カラムにはネストまたは繰り返しの構造が含まれる。\n検討 データの入力と生成 当初は元ファイルは適当なテキスト形式で作って CLI で出力しようとしていたが、テストデータ作成担当者の端末へのランタイムインストールの制限があった。\nそこで代替手段として Google Sheets にデータを入力してもらい、Google Apps Script でデータを生成するフローを採ることにした。\n最初はネストや繰り返しデータを各カラムに入力して、CSV形式でダウンロードしたもので対応できるかと思っていた。\nが、BigQuery にロードするデータでネストまたは繰り返しの構造が含まれる場合は CSV では連携できない。\n CSV ファイルはネストされたデータや繰り返しデータに対応していません。\nCloud Storage からの CSV データの読み込み - 制約事項\n ということで、Google Sheets の各セルの入力を JSONL に変換する必要がある。\nネストや繰り返し構造の実現 単純に一階層のハッシュ構造であれば\n   key1 key2     val11 val12   val21 val22    を\n1 2 3 4 5 6 7 8  { \u0026#34;key1\u0026#34;: \u0026#34;val11\u0026#34;, \u0026#34;key2\u0026#34;: \u0026#34;val12\u0026#34; }, { \u0026#34;key1\u0026#34;: \u0026#34;val21\u0026#34;, \u0026#34;key2\u0026#34;: \u0026#34;val22\u0026#34; }   するのは簡単だが、実際にはネストや繰り返しが入るので、この方式のままだと各セルに Object や Array を直接記述することになり、複雑なデータ構造を記載するときにミスが発生する可能性がある。\nCSV から JSON に変換したいという要望は一般にありそうだと思ったので、調べてみた。すると Node.js のライブラリ Keyang/node-csvtojson で Lodash の set メソッドを使った方法があったのでそれを使うことにした。\n1  Lodash.set(object, path, value)   という API で path に JavaScript のオブジェクト構造を設定すると中間階層を含めてオブジェクトを設定してくれる。\nこのメソッドを使うと\n   key1 key2.keykey21 key2.keykey22 key3.0 key3.1     val11 val12 val13 val14 val15   val21 val22 val23 val24 val25    から\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  { \u0026#34;key1\u0026#34;: \u0026#34;val11\u0026#34;, \u0026#34;key2\u0026#34;: { \u0026#34;keykey21\u0026#34;: \u0026#34;val12\u0026#34;, \u0026#34;keykey22\u0026#34;: \u0026#34;val13\u0026#34; }, \u0026#34;key3\u0026#34;: [ \u0026#34;val14\u0026#34;, \u0026#34;val15\u0026#34; ] }, { \u0026#34;key1\u0026#34;: \u0026#34;val21\u0026#34;, \u0026#34;key2\u0026#34;: { \u0026#34;keykey21\u0026#34;: \u0026#34;val22\u0026#34;, \u0026#34;keykey22\u0026#34;: \u0026#34;val23\u0026#34; }, \u0026#34;key3\u0026#34;: [ \u0026#34;val24\u0026#34;, \u0026#34;val25\u0026#34; ] }   を生成することができる。\n真偽値と NULL 上記までの対応で JSON のデータ型の\n 数値 文字列 配列 オブジェクト  は対応できた。残りの\n 真偽値 null  の対応が残っている。\n幸い Google Sheets にはシートに型が設定されていて、真偽値に関しては文字列エスケープ(先頭にシングルクォートを付ける)をしない TRUE / FALSE の文字列入力で対応できる。\n問題は null の方で、関数の処理の中では null はあるが、シートの記載はできないようなので、mysqldump のディフォルトと同じ \\N を null のテキスト表記として変換することにした。\nコード Lodash.js は Google Apps Script 版の contributorpw/lodashgs を使った。\n input シート： ヘッダとデータを記載 output シート： JSONL データを出力  エラー処理を除いてコードは以下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  function sheets2jsonl() { var _ = LodashGS.load(); var inputSheet = SpreadsheetApp.getActive().getSheetByName(\u0026#39;input\u0026#39;); var outputSheet = SpreadsheetApp.getActive().getSheetByName(\u0026#39;output\u0026#39;); var inputData = inputSheet.getDataRange().getValues(); var headerLine = inputData.shift(); var resultLines = []; for (var i = 0; i \u0026lt; inputData.length; i++) { var jsonLine = {}; for (var j = 0; j \u0026lt; headerLine.length; j++) { var value = (inputData[i][j] === \u0026#34;\\\\N\u0026#34;) ? null : inputData[i][j]; _.set(jsonLine, headerLine[j], value); } resultLines.push([JSON.stringify(jsonLine)]); } outputSheet.clear(); outputSheet.getRange(outputSheet.getLastRow() + 1, 1, resultLines.length, 1).setValues(resultLines); }   この関数を Google Sheets のシートのメニューに追加するなどすれば対応完了。\n"},{"uri":"https://noissefnoc.github.io/categories/productivity/","title":"productivity","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/posts/terraform-linter/","title":"terraform の linter の tflint を使う","tags":["terraform"],"categories":[],"series":[],"description":"","content":"tl;dr terraform-linters/tflint を使うことにしました。\nモチベーション  DSL とはいえ、言語を書くので Linter が欲しかった terraform plan で問題なさそうになっていても terraform apply で失敗するの辛いので事前に知りたい  メモ  --deep オプションの詳細を調べる インストール手順書く  "},{"uri":"https://noissefnoc.github.io/categories/infrastructure/","title":"infrastructure","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/posts/first-step-terraform-012/","title":"Terraform v0.12.x ことはじめ","tags":["terraform"],"categories":[],"series":[],"description":"","content":"tfenv: Terraform 自身のインストール・バージョン管理 メインのターゲットバージョンは v0.12.x だけど、古いものもあるので、複数バージョン使い分けたい。\nそのため tfenv を使うことにしました。Windowsがサポートされてないけど、一旦そこは保留。\nインストール macOS なので\n$ brew install tfenv でインストール。\nterraform のインストール 通常バージョンを指定してインストールするが\n last ：最新版 last:\u0026lt;regexp\u0026gt; ：特定マイナー/メジャーバージョン内の最新版 min-required ：.tf を見て必要な最小のバージョン  という記述も使える。\nterraform のバージョン固定 *env の設定にあるようにフォルダに設定ファイルを用意することでバージョンの指定ができる。\nファイル名は .terraform-version\n$ echo 0.12.0 \u0026gt; .terraform-version terraform 0.12.x のインストール 特に以前のバージョンはないので最新のバージョンを入れる\n$ tfenv install latest インストールされたバージョンで固定する。\ntfenv 向け $ echo 0.12.20 \u0026gt; .terraform-version .tf ファイル向け 1 2 3  terraform { required_version =\u0026#34;\u0026lt;=0.12.20\u0026#34; }   以上。\n"},{"uri":"https://noissefnoc.github.io/posts/terraform-console/","title":"terraform の Syntax と挙動を確認するのに terraform console を使う","tags":["terraform"],"categories":[],"series":[],"description":"","content":"久々に terraform を使うことになって大分 Syntax が変わっていたので、いくつか試してみたかったので、シンタックスチェックと REPL について調べた。\nSyntax 確認 Command: validate - terraform を使う。 terraform plan でもチェックが走るが、こちらだとリモートのリソースにアクセスしに行くのでファイルのみでのオフラインチェックができない。\nまた、 terraform validate を実行するためには terraform init を実行しておかなければならないのだが、 backend がリモートの場合 terraform init 実行時にリモートアクセスが走るので\n$ terraform init -backend=false を一度実行しておく。\n挙動確認 Command: console - terraform を使う。\n現在のディレクトリの state を使いたければ\n$ terraform console で REPL モードに入る。他の state を使いたければ -state=path で指定。\nREPL は exit ないしは C-C or C-D で終了。\nまた、以下のようにパイプで標準入力に HCL を渡せば\n$ echo \u0026quot;1 + 1\u0026quot; | terraform console 2 評価結果が返ってくる。\n"},{"uri":"https://noissefnoc.github.io/tags/aws/","title":"aws","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/posts/check-aws-account-id-and-user-by-cli/","title":"AWS CLI で現在の認証情報のアカウント ID とユーザを確認する","tags":["aws"],"categories":[],"series":[],"description":"","content":"諸事情で AWS 認証情報ファイル ~/.aws/credentials にプロファイルを書き込まずに環境変数だけで作業をしているときに、現在のアカウントを確認したくなる時があるので調べてみました。\nget-caller-identity - AWS CLI Command Reference\n$ aws sts get-caller-identity で、以下スキーマの JSON が返ってくる。\n1 2 3 4 5  { \u0026#34;Account\u0026#34;: \u0026#34;AWS_ACCOUNT_TWELVE_DIGIT\u0026#34;, \u0026#34;UserId\u0026#34;: \u0026#34;AWS_USER_ID\u0026#34;, \u0026#34;Arn\u0026#34;: \u0026#34;arn:aws:iam::AWS_ACCOUNT_TWELVE_DIGIT:user/USER\u0026#34; }   毎回実行するのもアレなので、本当は認証情報を環境変数に書き出すさいにユーザ定義環境変数にして書き出した方がいいのかもしれません。\n"},{"uri":"https://noissefnoc.github.io/categories/blog/","title":"blog","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/tags/github/","title":"github","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/posts/github-organization-search-tips/","title":"GtiHub の Organization 内だけに検索対象を絞る方法","tags":["github"],"categories":[],"series":[],"description":"","content":"そのままズバリ org:ORGNAME でできる。\nユーザまたは Organization のリポジトリ内の検索\nユーザの場合は同様に user:USERNAME になる。\n"},{"uri":"https://noissefnoc.github.io/tags/python/","title":"python","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/posts/python-cli-behavior-under-venv/","title":"Python の venv でインストールした CLI の挙動","tags":["python"],"categories":[],"series":[],"description":"","content":"Python の venv を使って仮想環境を作って pip install していくと venv/bin や venv/lib 以下にファイルがインストールされるまでは知っていたが、 source venv/bin/activate せずに venv/bin/some-cli したときの Python の環境はどれを使っているんだろうかと疑問になったので調べてみた。\n公式ドキュメントの venv \u0026ndash; 仮想環境の作成 にずばり答えが書いてあって\n 仮想環境にインストールされたスクリプトには、仮想環境の Python インタプリタを指す \u0026ldquo;shebang\u0026rdquo; 行があります。 これはつまり、スクリプトは PATH の値に関係無く、仮想環境のインタプリタで実行されるということです。\n ということで venv/bin/some-cli の shebang を見ると\n1  #! /path/to/project_root/venv/bin/python   となっており、該当 venv の Python が呼ばれるように指定されていた。\nそういう仕組みなのかと感心しました。\n"},{"uri":"https://noissefnoc.github.io/categories/reference/","title":"reference","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/posts/python-mutiplatform-userdir/","title":"Python でマルチプラットフォームのファイルパスを扱う","tags":["python"],"categories":[],"series":[],"description":"","content":"AWS のクレデンシャルファイルのパスが Widnows と　POSIX 互換システムで以下のように違う。\n Windows: %USERPROFILE%\\.aws\\credentials その他： $HOME/.aws/credentials  これをプラットフォームの分岐なしで記載したい。\n os.path.expanduser : マルチプラットフォームでユーザのホームディレクトリを取得 os.path.join : マルチプラットフォームのパスの結合 (セパレータを加味)  を使って以下のように記載する。\n1 2 3 4 5  from os.path import expanduser, join if __name__ == \u0026#39;__main__\u0026#39;: user_home_path = expanduser(\u0026#39;~\u0026#39;) aws_credential_file_path = join(user_home_path, \u0026#39;.aws\u0026#39;, \u0026#39;credentials\u0026#39;)   以上。\n"},{"uri":"https://noissefnoc.github.io/tags/zsh/","title":"zsh","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/posts/zsh-plugin-management-by-zplugin/","title":"zsh のプラグインマネージャーに zplugin を使うことにした","tags":["zsh"],"categories":[],"series":[],"description":"","content":"tl;dr macOS のバージョンアップに伴って zsh を使い始めたので、プラグインマネージャを検討した結果 zplugin を使うことにした。\n経緯 bash のときはプラグインマネージャーを使っていなかったけれど、 zsh 使っている人から Oh my zsh のような存在は聞かされていたので、プラグインあるだろうと思ってプラグインマネージャーを調べたところ\n vim で使っていた(多分 neobundle + vim-plug) プラグインマネージャと似たような設定方法 同じ設定方式の中では動作が速い  という理由で zplugin を選びました。\n設定 まだよく分かっていないのですが、コマンドタイプしていくとサジェストが出るプラグインと、ターミナル上でシンタックスハイライトが付くプラグインを入れてみました。\n~/.zshrc に以下を追加しておいて\n1 2  zplugin light zsh-users/zsh-autosuggestions zplugin light zdharma/fast-syntax-highlighting   再読み込みされたタイミングでインストールされていなければインストールされる仕組みになっています。\nこの後のTODO ちゃんと使いそうなプラグインと、起動時に読み込まなくてもいいプラグインなど、導入と精査を進めていきたいと思います。\n"},{"uri":"https://noissefnoc.github.io/posts/zsh-env-path-settings/","title":"zsh で環境変数 PATH 周りの設定","tags":["zsh"],"categories":[],"series":[],"description":"","content":"tl;dr macOS Catalina からユーザのログインシェルが zsh に変わり、 bash を使っていると「zsh を使え」と警告文が出るので、ボチボチ移行しています。\n今回は環境変数 PATH の設定の話についてのメモ。\n 環境変数の記述ファイル zsh で使える配列変数 path パスが存在するときだけ PATH に追加 PATH 中の重複パス削除  環境変数の記述ファイル 環境変数は ~/.zshenv に書くのが正しいらしいので、そちら側に移動。\nzsh で使える配列変数 path 環境変数 PATH と同期している配列変数 path が使える。\n1  export PATH=\u0026#34;/usr/local/bin:$PATH\u0026#34;   は\n1 2 3 4  path=( /usr/local/bin $path )   と同義。path の方が追加/削除が簡単なのと、次に書くパスが存在する時だけ追加するオプションが利用できるのでこっちを使う。\nパスが存在する時だけ PATH に追加 配列変数 path だと、追加パスの末尾に (N-/) をつけることでパスが存在する場合だけ追加することができる。\n1 2 3 4 5  path=( $HOME/bin(N-/) /usr/local/bin $path )   のような形。 .*env 系など、ユーザが自分で作成しないとないパスを PATH に追加するときに便利。\nPATH の中の重複パス削除 諸々あって、 PATH の追加が何回も呼ばれてしまって、重複したパスが追加されたりするケースで、 bash だと少しサイクが必要だったが、zsh だと\n1  typeset -U path   を使えば良い。これを ~/.zshrc の最後に書いてる。\n"},{"uri":"https://noissefnoc.github.io/posts/python3-type-hinting-mypy-summary/","title":"Python3 の Type Hinting の早見表","tags":["python"],"categories":[],"series":[],"description":"","content":"Python 3.5+ から PEP484 にある型ヒントで「この場合どう書いたらいいんだっけ」というのが分からなかったので調べてみた。\nすると Mypy のサイトに以下のようなページがありました。\nType hints cheat sheet (Python 3)\n関数のディフォルト値 例えば関数のディフォルト値なら\n1 2  def inc(d: int = 1): return d + 1   のように変数ではなく、型の方にディフォルト値を書く。\nクラス 独自クラスに関してはそのままが型になる\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  from typing import List class Hoge: # これはコンストラクタが返ってきてる気がするけど None らしい def __init__(self) -\u0026gt; None: self.foo: List[str] = [] # インスタンスメソッドの self の方は省略する def i_method(self, i: int) -\u0026gt; int; return i + 1 if __name__ == \u0026#39;__main__\u0026#39;: # ユーザ定義のクラスの型はそのままクラス名 x: Hoge = Hoge()   その他 自分で書いた範囲に関してはこのページの内容で問題なさそうですが\n 外部のライブラリを使ったときはどうなるのか 有名なライブラリには型ファイルが用意されているものか  あたりはまた別途調べてみようと思います。\n"},{"uri":"https://noissefnoc.github.io/posts/python-input-func-to-stderr/","title":"Python の input 関数の出力を標準エラー出力に向ける","tags":["python"],"categories":[],"series":[],"description":"","content":"もう少しマシな方法があるかもしれないけれど、一旦できたので記録。\nPython で CLI を作っていて、Username/Password を対話的に入力して環境変数を export する構文を出力したいという要件があった。\n例示すると以下\n# そのまま実行すると以下 $ python cli.py Username: # ユーザ名を対話的に入力 Password: # パスワードを対話的に入力 export X_TOKEN=yyyyy # こうやると環境変数に定義されて欲しい $ $(python cli.py) $ echo ${X_TOKEN} yyyyy 上記のようにするためにはUsernameとPasswordのプロンプト両方が標準出力ではなく、標準エラー出力に出力して、環境変数の箇所だけを標準出力に出力する必要がある。\nPassowrd のように echo back させない対話入力は getpass モジュールの getpass 関数を使う\ngetpass \u0026mdash; 可搬性のあるパスワード入力機構\ngetpass 関数には stream 引数にプロンプトの出力先を変更できる。\n1 2 3 4 5 6  from getpass import getpass import sys if __name__ == \u0026#39;__main__\u0026#39;: password = getpass(\u0026#39;Password: \u0026#39;, stream=sys.stderr)   問題は echo back する方で、標準の input 関数を使うのだけど、これには出力先を選択するオプションがない。\n組み込み関数 \u0026mdash; input()\n調べてみると10年以上前から issue には上がっていた\nChange input() to always prompt to stderr\nここに上がっているパッチだと単純に stdout を stderr に差し替えられていたが、マージされる様子はなさそうだった。\nPython のレイヤーで言うと getpass.getpass と同じようにオプション引数を追加すればいいような話ではあるが、実態の PyOS_Readline あたりの諸々に影響がある？\n暫定的な対応をすると getpass 関数と合わせて以下のような処理を書いた。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  import sys from typing import IO def getusername(prompt: str, stream: IO[str] = sys.stderr) -\u0026gt; str: # 標準出力を指定した先に変更 sys.stdout = stream # 対話的に入力を取得 username = input(prompt) # 標準出力を処理起動時の標準出力に戻す sys.stdout = sys.__stdout__ return username if __name__ == \u0026#39;__main__\u0026#39;: try: username = getusername(\u0026#39;Username: \u0026#39;) except KeyboardInterrupt: # input 関数実行時に Ctrl-C などで止められたときに標準出力を元に戻しておく # ここやる必要ないかも sys.stdout = sys.__stdout__   他にいい方法があるかもしれないが、一旦はこんなもので\n"},{"uri":"https://noissefnoc.github.io/tags/github-actions/","title":"github-actions","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/posts/hugo-blog-open/","title":"Hugo + GitHub Pages + GitHub Actions で技術メモを開始した","tags":["golang","github-actions"],"categories":[],"series":[],"description":"","content":"GitHub の草を生やすのにできればコードを書き続けたいのですが、昨年トライしてみたところそうもいかないことがありました。\n過分余暇時間で Blog を書いたりスニペットを書いたりもするのですが、両方とも GitHub の Contributions に反映されないので、反映できるようにまずは　Blog を GitHub Pages にしてみました。\nスタックは\n Visual Code Studio: エディタ Hugo: 静的ファイルネジェレータ Hugo テーマ: Zzo ホスティング: GitHub Pages ジェネレート: GitHub Actions  で実施しています。\ngit push をトリガーにして GitHub Actions で master ブランチにジェネレートされた静的ファイルをコミットし、 GitHub Pages に反映するようにしています。\nReference  Hugo Hugo Theme Zzo GitHub Actions Hugo Setup GitHub Actions GitHub Pages  "},{"uri":"https://noissefnoc.github.io/posts/github-basic-auth-deprecation/","title":"GitHub の Basic Auth の Deprecation に伴って Homebrew を Personal Token で認証するように変更した","tags":["github","homebrew"],"categories":[],"series":[],"description":"","content":"GitHubから [GitHub] Deprecation Notice というタイトルで以下の内容のメールが来た\n You recently used a password to access an endpoint through the GitHub API using Homebrew/*************. We will deprecate basic authentication using password to this endpoint soon: ※ User Agentは一部マスク\nhomebrew コマンドで Basic Auth を使っていて Personal Access Token に対応してなかった様子。 man brew でそれらしいセクションを探すと\n HOMEBREW_GITHUB_API_TOKEN A personal access token for the GitHub API, used by Homebrew for features such as brew search. You can create one at https://github.com/settings/tokens. If set, GitHub will allow you a greater number of API requests. For more information, see: https://developer.github.com/v3/#rate-limiting Note: Homebrew doesn't require permissions for any of the scopes. とあったので Settings \u0026gt; Developer \u0026gt; Personal Access Token で homebrew 用の Token を作成して環境変数にセットした。\n"},{"uri":"https://noissefnoc.github.io/tags/homebrew/","title":"homebrew","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/categories/mainteinance/","title":"mainteinance","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/archive/","title":"Archive","tags":[],"categories":[],"series":[],"description":"Archive Page","content":"archive page\n"},{"uri":"https://noissefnoc.github.io/tags/bigquery/","title":"bigquery","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/posts/bigquery-gis-to-datastudio/","title":"Bigquery GIS のデータを Google DataStudio で使う方法","tags":["bigquery","datastudio","gis","sql"],"categories":[],"series":[],"description":"","content":"tl;dr Google BigQuery の GEOGRAPHY データ型はそのままでは Google DataStudio では使えないので(取り込み対象カラムとして表示されない)以下のように変換しておく必要がある。\n1 2 3 4  SELECT CONCAT(CAST(ST_Y(p) AS STRING), \u0026#34;,\u0026#34;, CAST(ST_X(p) AS STRING)) AS lat_lng FROM my_project.geo_table   このさい\n GEOGRAPHY データ型  (経度, 緯度) で保存されている (つまり ST_Y で緯度、 ST_X で経度が取れるということ)   DataStudio の緯度経度型  緯度,経度 のフォーマットを期待している    と、緯度経度の順番が逆になっていることに注意。\n本文 きっかけ Google BigQuery の地理情報をデータポータルで可視化する仕事があったが、データポータルの BigQuery テーブル指定だと GEOGRAPHY 型のカラムが出てこなかった。\n対応 データポータルで読み取れるのは緯度経度なので\n BigQuery であらかじめ変換したテーブルを用意しておく データポータルの BigQuery 取得でカスタムクエリを書く  の方法が考えられますが、今回は後者を選びました。\nカスタムクエリに以下のようなクエリをセットして\n1 2 3 4 5 6 7  -- カスタムクエリに記載するクエリ SELECT -- その他のカラム  CONCAT(CAST(ST_Y(p) AS STRING), \u0026#34;,\u0026#34;, CAST(ST_X(p) AS STRING)) AS lat_lng FROM my_project.geo_table -- その他絞り込み条件   データポータルのカラムの設定マッピングで「地理フィールド」\u0026gt;「緯度/経度」を選択して完了です。\nReference  BigQuery GIS の構文リファレンス - ST_X: SQL のサンプルの記載がある データポータルのヘルプ - 地図のリファレンス：「地理フィールド」の「緯度 / 経度」の箇所  "},{"uri":"https://noissefnoc.github.io/tags/datastudio/","title":"datastudio","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/tags/gis/","title":"gis","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/tags/sql/","title":"sql","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/tags/c/c++/","title":"c/c++","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/tags/index/","title":"index","tags":[],"categories":[],"series":[],"description":"","content":""},{"uri":"https://noissefnoc.github.io/series/","title":"Series","tags":[],"categories":[],"series":[],"description":"","content":""}]